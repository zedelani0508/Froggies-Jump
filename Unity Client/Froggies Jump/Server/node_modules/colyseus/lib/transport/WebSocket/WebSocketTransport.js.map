{"version":3,"file":"WebSocketTransport.js","sourceRoot":"","sources":["../../../src/transport/WebSocket/WebSocketTransport.ts"],"names":[],"mappings":"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","sourcesContent":["import http from 'http';\nimport querystring from 'querystring';\nimport url from 'url';\nimport WebSocket from 'ws';\n\nimport * as matchMaker from '../../MatchMaker';\nimport { Protocol } from '../../Protocol';\n\nimport { ServerOptions } from '../../Server';\nimport { Transport } from '../Transport';\n\nimport { debugAndPrintError, debugConnection } from '../../Debug';\nimport { WebSocketClient } from './WebSocketClient';\n\nfunction noop() {/* tslint:disable:no-empty */ }\nfunction heartbeat() { this.pingCount = 0; }\n\ntype RawWebSocketClient = WebSocket & { pingCount: number };\n\nexport class WebSocketTransport extends Transport {\n  protected wss: WebSocket.Server;\n\n  protected pingInterval: NodeJS.Timer;\n  protected pingIntervalMS: number;\n  protected pingMaxRetries: number;\n\n  constructor(options: ServerOptions = {}, engine: any) {\n    super();\n\n    // disable per-message deflate\n    options.perMessageDeflate = false;\n\n    if (options.pingTimeout !== undefined) {\n      console.warn('\"pingTimeout\" is deprecated. Use \"pingInterval\" instead.');\n      options.pingInterval = options.pingTimeout;\n    }\n\n    if (options.pingCountMax !== undefined) {\n      console.warn('\"pingCountMax\" is deprecated. Use \"pingMaxRetries\" instead.');\n      options.pingMaxRetries = options.pingCountMax;\n    }\n\n    this.pingIntervalMS = (options.pingInterval !== undefined)\n      ? options.pingInterval\n      : 3000;\n    this.pingMaxRetries = (options.pingMaxRetries !== undefined)\n      ? options.pingMaxRetries\n      : 2;\n\n    this.wss = new engine(options);\n    this.wss.on('connection', this.onConnection);\n\n    // this is required to allow the ECONNRESET error to trigger on the `server` instance.\n    this.wss.on('error', (err) => debugAndPrintError(err));\n\n    this.server = options.server;\n\n    if (this.pingIntervalMS > 0 && this.pingMaxRetries > 0) {\n      this.server.on('listening', () =>\n        this.autoTerminateUnresponsiveClients(this.pingIntervalMS, this.pingMaxRetries));\n\n      this.server.on('close', () =>\n        clearInterval(this.pingInterval));\n    }\n  }\n\n  public listen(port: number, hostname?: string, backlog?: number, listeningListener?: () => void) {\n    this.server.listen(port, hostname, backlog, listeningListener);\n    return this;\n  }\n\n  public shutdown() {\n    this.wss.close();\n    this.server.close();\n  }\n\n  public simulateLatency(milliseconds: number) {\n    const previousSend = WebSocket.prototype.send;\n    WebSocket.prototype.send = function(...args: any[]) {\n      setTimeout(() => previousSend.apply(this, args), milliseconds);\n    };\n  }\n\n  protected autoTerminateUnresponsiveClients(pingInterval: number, pingMaxRetries: number) {\n    // interval to detect broken connections\n    this.pingInterval = setInterval(() => {\n      this.wss.clients.forEach((client: RawWebSocketClient) => {\n        //\n        // if client hasn't responded after the interval, terminate its connection.\n        //\n        if (client.pingCount >= pingMaxRetries) {\n          // debugConnection(`terminating unresponsive client ${client.sessionId}`);\n          debugConnection(`terminating unresponsive client`);\n          return client.terminate();\n        }\n\n        client.pingCount++;\n        client.ping(noop);\n      });\n    }, pingInterval);\n  }\n\n  protected async onConnection(rawClient: RawWebSocketClient, req?: http.IncomingMessage & any) {\n    // prevent server crashes if a single client had unexpected error\n    rawClient.on('error', (err) => debugAndPrintError(err.message + '\\n' + err.stack));\n    rawClient.on('pong', heartbeat);\n\n    // compatibility with ws / uws\n    const upgradeReq = req || (rawClient as any).upgradeReq;\n    const parsedURL = url.parse(upgradeReq.url);\n\n    const sessionId = querystring.parse(parsedURL.query).sessionId as string;\n    const processAndRoomId = parsedURL.pathname.match(/\\/[a-zA-Z0-9_\\-]+\\/([a-zA-Z0-9_\\-]+)$/);\n    const roomId = processAndRoomId && processAndRoomId[1];\n\n    const room = matchMaker.getRoomById(roomId);\n\n    // set client id\n    rawClient.pingCount = 0;\n\n    const client = new WebSocketClient(sessionId, rawClient);\n\n    try {\n      if (!room || !room.hasReservedSeat(sessionId)) {\n        throw new Error('seat reservation expired.');\n      }\n\n      await room._onJoin(client, upgradeReq);\n\n    } catch (e) {\n      debugAndPrintError(e);\n\n      // send error code to client then terminate\n      client.error(e.code, e.message, () =>\n        rawClient.close(Protocol.WS_CLOSE_WITH_ERROR));\n    }\n  }\n\n}\n"]}